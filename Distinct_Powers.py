# Consider all integer combinations of a^b 
# for 2 <= a <= 5 and 2 <= b <= 5:
# 2^2=4, 2^3=8, 2^4=16, 2^5=32
# 3^2=9, 3^3=27, 3^4=81, 3^5=243
# 4^2=16, 4^3=64, 4^4=256, 4^5=1024
# 5^2=25, 5^3=125, 5^4=625, 5^5=3125

# If they are then placed in numerical order, with any repeats removed,
# we get the following sequence of 15 distinct terms:
# 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

# How many distinct terms are in the sequence generated by a^b
# for 2 <= a <= 100 and 2 <= b <= 100?

from reusable_functions import primes_list, extend_primes_list_up_to
#get primes under 100
extend_primes_list_up_to(100)

#create power representions of numbers using a sorted primes_list
def power_representation(n:int):
    i = 0
    representation = []
    while n!=1:
        power = 0
        prime = primes_list[i]
        while n%prime == 0:
            n = n//prime
            power+=1
        representation.append(power)
        i+=1
    return representation

def raise_to_power(representation:list[int], power:int):
    return [a*power for a in representation]

#create power representaions for a^b for 2 <= a <= 100 and 2 <= b <= 100
representations = set()

for a in range(2, 101):
    a_representation = power_representation(a)
    for b in range(2, 101):
        a_to_the_b_representation = raise_to_power(a_representation, b)
        representations.add(str(a_to_the_b_representation))

print(len(representations))



#or as another person in the forum put it:
l = set()
for a in range(2,101):
        for b in range (2,101):
                c = a**b
                l.add(c)
print(len(l))
#I overcomplicated the process because I thought that 
# 100^100 is bound to escape integer limits
# so I cam up with a scheme that can represent the numbers using prime powers
# so the maximum would be 64^100 -> 2^(6*100) -> 600
# but as it turns out python 3 switched to an integer representaion 
# that is limited only by your memory
from math import pi, floor
print(floor(100 * 100**100 * pi))